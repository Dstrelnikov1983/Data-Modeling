# Векторные базы данных

## Краткая справка

---

## 1. Что такое векторная база данных

Векторная база данных (Vector Database) — специализированная система управления данными, оптимизированная для хранения, индексации и поиска многомерных векторов (эмбеддингов). В отличие от реляционных БД, где поиск основан на точном совпадении значений, векторные БД выполняют **поиск ближайших соседей** (Approximate Nearest Neighbor, ANN) в многомерном пространстве.

```
Традиционная БД:              Векторная БД:

  SELECT * FROM docs             Найти 5 ближайших векторов
  WHERE title = 'ПДМ-7'         к вектору запроса [0.12, -0.34, ...]

  ┌────────┐                     Многомерное пространство:
  │ Точное │                         •  •
  │совпаде-│                       •    ★ ← запрос
  │  ние   │                         •  •  •
  └────────┘                           •
```

---

## 2. Как создаются векторы (эмбеддинги)

Эмбеддинг — числовое представление данных (текста, изображений, аудио) в виде вектора фиксированной размерности, где семантически близкие объекты расположены рядом в векторном пространстве.

```
Текст                          Модель эмбеддингов        Вектор
┌──────────────────────┐      ┌──────────────────┐      ┌──────────────────┐
│ "Погрузочно-         │      │                  │      │ [0.023, -0.147,  │
│  доставочная машина  │─────▶│  text-embedding  │─────▶│  0.891, 0.034,   │
│  вышла из строя"     │      │  (1536 измерений)│      │  ..., -0.562]    │
└──────────────────────┘      └──────────────────┘      └──────────────────┘

"ПДМ сломалась"        ──────▶  [0.021, -0.152, 0.887, ...]  ← близкий вектор
"Цена акций выросла"   ──────▶  [0.734, 0.412, -0.203, ...]  ← далёкий вектор
```

**Популярные модели эмбеддингов:**

| Модель | Размерность | Провайдер | Примечание |
|--------|-------------|-----------|------------|
| text-embedding-3-large | 3072 | OpenAI | Высокое качество |
| text-embedding-3-small | 1536 | OpenAI | Баланс цена/качество |
| E5-large-v2 | 1024 | Microsoft | Open Source |
| BGE-M3 | 1024 | BAAI | Мультиязычный |
| YandexGPT Embeddings | 256 | Yandex | Русский язык |
| GigaChat Embeddings | 1024 | Сбер | Русский язык |
| all-MiniLM-L6-v2 | 384 | Sentence-Transformers | Быстрый, компактный |

---

## 3. Метрики расстояния между векторами

Выбор метрики определяет, как измеряется «близость» векторов.

### 3.1. Косинусное сходство (Cosine Similarity)

Измеряет угол между векторами, игнорируя их длину. Наиболее популярная метрика для текстовых эмбеддингов.

```
              B
             ╱
            ╱  θ = малый угол → высокое сходство
           ╱
          ╱
    ─────A──────────

    similarity = cos(θ) = (A · B) / (|A| × |B|)

    Диапазон: [-1, 1]
    1  = идентичные направления
    0  = ортогональные (не связаны)
    -1 = противоположные
```

### 3.2. Евклидово расстояние (L2)

Прямое расстояние между точками. Чувствительно к масштабу.

```
    distance = √Σ(aᵢ - bᵢ)²

    Диапазон: [0, +∞)
    0 = идентичные векторы
    Чем меньше — тем ближе
```

### 3.3. Скалярное произведение (Dot Product / Inner Product)

Учитывает и направление, и длину. Используется, когда длина вектора несёт смысловую нагрузку (например, «важность» документа).

```
    score = Σ(aᵢ × bᵢ)

    Диапазон: (-∞, +∞)
    Больше = более похожи
```

### Сравнение метрик

| Метрика | Когда использовать | Нормализация нужна? |
|---------|--------------------|---------------------|
| Cosine | Семантический поиск текста | Нет (встроена) |
| L2 (Euclidean) | Кластеризация, аномалии | Желательна |
| Dot Product | Рекомендации, ранжирование | Да |

---

## 4. Алгоритмы индексации

Точный поиск ближайшего соседа (brute-force) требует сравнения со всеми векторами — O(n). Для миллионов и миллиардов записей применяют приближённые алгоритмы (ANN).

### 4.1. HNSW (Hierarchical Navigable Small World)

Наиболее популярный алгоритм. Строит многослойный граф, где верхние слои содержат «дальнобойные» связи, а нижние — локальные.

```
Слой 2 (грубый):    A ─────────────────── F
                    │                     │
Слой 1 (средний):   A ──── C ──── E ──── F
                    │      │      │      │
Слой 0 (точный):    A ─ B ─ C ─ D ─ E ─ F ─ G ─ H

Поиск: сверху вниз, от грубого к точному
```

| Параметр | Описание | Влияние |
|----------|----------|---------|
| `M` | Число связей на узел | Больше → точнее, но больше памяти |
| `ef_construction` | Глубина поиска при построении | Больше → лучше индекс, дольше строится |
| `ef_search` | Глубина поиска при запросе | Больше → точнее, но медленнее |

**Характеристики:** recall > 95%, поиск за ~1 мс на 1 млн векторов, хранение в памяти.

### 4.2. IVF (Inverted File Index)

Разбивает пространство на кластеры (ячейки Вороного). При поиске проверяются только ближайшие кластеры.

```
    ┌─────────┬─────────┬─────────┐
    │ Кластер │ Кластер │ Кластер │
    │    1    │    2    │    3    │
    │  • •    │  • •    │    •    │
    │    •    │  • ★    │  •  •   │   ★ = запрос
    │         │    •    │         │   Ищем только
    ├─────────┼─────────┼─────────┤   в кластерах
    │ Кластер │ Кластер │ Кластер │   2 и 5
    │    4    │    5    │    6    │
    │  •      │  •  •   │    •    │
    │    •  • │    •    │  •      │
    └─────────┴─────────┴─────────┘

    nlist = 6 кластеров
    nprobe = 2 (проверяем 2 ближайших)
```

### 4.3. PQ (Product Quantization)

Сжимает векторы, разбивая на подвекторы и квантуя каждый отдельно. Снижает потребление памяти в 10–100 раз.

```
Исходный вектор (1536 измерений):
[0.12, -0.34, 0.56, 0.78, ..., -0.91]

Разбиение на 8 подвекторов по 192 измерения:
[sub_1] [sub_2] [sub_3] ... [sub_8]

Квантование каждого подвектора (256 центроидов):
[42]    [117]   [8]     ... [203]    ← 8 байт вместо 6144
```

### 4.4. Сравнение алгоритмов

| Алгоритм | Скорость поиска | Память | Точность (Recall) | Обновления |
|----------|----------------|--------|-------------------|------------|
| Brute Force | Медленно | Низкая | 100% | Мгновенные |
| HNSW | Очень быстро | Высокая | 95–99% | Быстрые |
| IVF | Быстро | Средняя | 90–98% | Перестройка кластеров |
| IVF + PQ | Быстро | Низкая | 85–95% | Перестройка |
| HNSW + PQ | Очень быстро | Средняя | 90–97% | Быстрые |

---

## 5. Обзор векторных баз данных

### 5.1. Специализированные векторные БД

#### Qdrant

```
Тип: Open Source (Rust)
Лицензия: Apache 2.0
Размещение: Self-hosted / Qdrant Cloud
```

**Особенности:**
- Написан на Rust — высокая производительность и надёжность
- Поддержка фильтрации по payload (метаданным) при поиске
- Мультитенантность через коллекции
- Поддержка sparse-векторов для гибридного поиска
- Снапшоты и репликация

```python
from qdrant_client import QdrantClient
from qdrant_client.models import VectorParams, Distance, PointStruct

client = QdrantClient(host="localhost", port=6333)

# Создание коллекции
client.create_collection(
    collection_name="equipment_docs",
    vectors_config=VectorParams(
        size=1536,
        distance=Distance.COSINE
    )
)

# Вставка вектора
client.upsert(
    collection_name="equipment_docs",
    points=[
        PointStruct(
            id=1,
            vector=[0.12, -0.34, ...],  # 1536 измерений
            payload={
                "text": "Регламент ТО для ПДМ-7",
                "equipment_type": "ПДМ",
                "mine": "Северная"
            }
        )
    ]
)

# Поиск с фильтрацией
results = client.search(
    collection_name="equipment_docs",
    query_vector=[0.11, -0.32, ...],
    query_filter={
        "must": [
            {"key": "equipment_type", "match": {"value": "ПДМ"}}
        ]
    },
    limit=5
)
```

#### Milvus

```
Тип: Open Source (Go + C++)
Лицензия: Apache 2.0
Размещение: Self-hosted / Zilliz Cloud
```

**Особенности:**
- Горизонтальное масштабирование (distributed architecture)
- Поддержка миллиардов векторов
- GPU-ускорение индексации
- Встроенная поддержка нескольких индексов (HNSW, IVF, DiskANN)
- Гибридный поиск (вектор + скаляр)

#### Weaviate

```
Тип: Open Source (Go)
Лицензия: BSD-3
Размещение: Self-hosted / Weaviate Cloud
```

**Особенности:**
- Встроенные модули для генерации эмбеддингов (не нужен отдельный сервис)
- GraphQL API
- Гибридный поиск: BM25 + вектор
- Мультимодальность (текст, изображения)
- Автоматическая классификация

#### Pinecone

```
Тип: Managed SaaS (проприетарный)
Размещение: Только облако
```

**Особенности:**
- Полностью управляемый сервис, нет самостоятельного развёртывания
- Серверлесс-архитектура
- Автоматическое масштабирование
- Высокая доступность (SLA 99.95%)
- Простой API

#### Chroma

```
Тип: Open Source (Python)
Лицензия: Apache 2.0
Размещение: Self-hosted / Chroma Cloud
```

**Особенности:**
- Максимально простой API (4 функции)
- Встраивание в Python-приложения (in-process)
- Идеален для прототипов и небольших проектов
- Встроенная генерация эмбеддингов
- Поддержка персистентного хранения

```python
import chromadb

client = chromadb.Client()
collection = client.create_collection("equipment")

collection.add(
    documents=["Регламент ТО для ПДМ-7", "Инструкция по эксплуатации"],
    ids=["doc1", "doc2"],
    metadatas=[{"type": "maintenance"}, {"type": "manual"}]
)

results = collection.query(
    query_texts=["обслуживание погрузочной машины"],
    n_results=3
)
```

---

### 5.2. Расширения для существующих СУБД

#### pgvector (PostgreSQL)

```
Тип: Расширение PostgreSQL
Лицензия: PostgreSQL License (аналог MIT)
```

Позволяет хранить векторы и выполнять ANN-поиск прямо в PostgreSQL — без дополнительных систем.

```sql
-- Установка расширения
CREATE EXTENSION vector;

-- Создание таблицы с векторным столбцом
CREATE TABLE document_chunks (
    chunk_id    SERIAL PRIMARY KEY,
    doc_title   VARCHAR(500),
    chunk_text  TEXT,
    metadata    JSONB,
    embedding   VECTOR(1536)
);

-- Загрузка данных
INSERT INTO document_chunks (doc_title, chunk_text, embedding)
VALUES (
    'Регламент ТО ПДМ-7',
    'Плановое техническое обслуживание выполняется каждые 250 моточасов...',
    '[0.023, -0.147, 0.891, ...]'::vector
);

-- Создание индекса HNSW
CREATE INDEX idx_chunks_hnsw
ON document_chunks
USING hnsw (embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 200);

-- Семантический поиск (Top-5 ближайших)
SELECT
    doc_title,
    chunk_text,
    1 - (embedding <=> '[0.021, -0.152, ...]'::vector) AS similarity
FROM document_chunks
ORDER BY embedding <=> '[0.021, -0.152, ...]'::vector
LIMIT 5;

-- Гибридный поиск: вектор + фильтр по метаданным
SELECT doc_title, chunk_text
FROM document_chunks
WHERE metadata->>'equipment_type' = 'ПДМ'
ORDER BY embedding <=> $1
LIMIT 5;
```

**Операторы расстояния в pgvector:**

| Оператор | Метрика | Описание |
|----------|---------|----------|
| `<->` | L2 (Euclidean) | Евклидово расстояние |
| `<=>` | Cosine | Косинусное расстояние |
| `<#>` | Inner Product | Скалярное произведение (отрицательное) |

**Типы индексов:**

| Тип | Команда | Когда использовать |
|-----|---------|-------------------|
| IVFFlat | `USING ivfflat` | < 1 млн записей, быстрое построение |
| HNSW | `USING hnsw` | Высокая точность, быстрый поиск |

#### Elasticsearch / OpenSearch (kNN)

Встроенная поддержка dense_vector полей и ANN-поиска через HNSW.

```json
{
  "query": {
    "knn": {
      "field": "embedding",
      "query_vector": [0.12, -0.34, ...],
      "k": 10,
      "num_candidates": 100
    }
  }
}
```

#### ClickHouse (annoy / usearch)

Экспериментальная поддержка ANN-индексов для аналитических задач.

#### Redis (RediSearch)

Векторный поиск поверх in-memory хранилища для сценариев с минимальной задержкой.

---

### 5.3. Сравнительная таблица

| Характеристика | pgvector | Qdrant | Milvus | Weaviate | Pinecone | Chroma |
|---------------|----------|--------|--------|----------|----------|--------|
| **Тип** | Расширение PG | Standalone | Standalone | Standalone | SaaS | Встраиваемая |
| **Язык** | C | Rust | Go/C++ | Go | — | Python |
| **Масштаб** | До 10 млн | До 100 млн | До 1 млрд+ | До 100 млн | До 1 млрд | До 1 млн |
| **Гибридный поиск** | SQL-фильтры | Payload-фильтры | Скалярные фильтры | BM25 + вектор | Metadata-фильтры | Metadata |
| **Индексы** | IVFFlat, HNSW | HNSW | HNSW, IVF, DiskANN | HNSW | Проприетарный | HNSW |
| **GPU** | Нет | Нет | Да | Нет | — | Нет |
| **Управление** | Сам. / Managed PG | Сам. / Cloud | Сам. / Zilliz | Сам. / Cloud | Только Cloud | Сам. / Cloud |
| **Преимущество** | Единая БД | Производительность | Масштаб | Простота | Без ops | Прототипы |
| **Стоимость** | Бесплатно | Бесплатно / $ | Бесплатно / $ | Бесплатно / $ | $$$ | Бесплатно |

---

## 6. Паттерны использования

### 6.1. Semantic Search (Семантический поиск)

Поиск по смыслу, а не по ключевым словам.

```
Запрос: "машина не заводится"

Ключевой поиск (BM25):            Семантический поиск (вектор):
✗ "Процедура запуска двигателя"    ✓ "Процедура запуска двигателя"
✓ "Машина вышла из строя"          ✓ "Диагностика неисправностей ДВС"
✗ "Диагностика неисправностей"     ✓ "Устранение проблем с зажиганием"
```

### 6.2. RAG (Retrieval-Augmented Generation)

Дополнение LLM релевантным контекстом из базы знаний.

```
┌─────────────┐      ┌──────────────┐      ┌─────────────┐
│   Запрос    │─────▶│ Векторная БД │─────▶│    LLM      │
│ пользователя│      │  (поиск)     │      │ (генерация) │
└─────────────┘      └──────────────┘      └─────────────┘
                           │                      ▲
                     Top-K документов              │
                           └──────────────────────┘
                              (контекст промпта)
```

### 6.3. Гибридный поиск (Hybrid Search)

Комбинация векторного и ключевого поиска для повышения качества.

```
                    Запрос
                      │
            ┌─────────┴─────────┐
            ▼                   ▼
     Векторный поиск      BM25 / ключевой
     (семантика)          (точные совпадения)
            │                   │
            └─────────┬─────────┘
                      ▼
              Reciprocal Rank
              Fusion (RRF)
                      │
                      ▼
              Объединённый
              результат
```

**Формула RRF:**

```
RRF_score(d) = Σ  1 / (k + rank_i(d))

Где:
  k = 60 (константа)
  rank_i(d) = позиция документа d в i-м списке результатов
```

### 6.4. Мультимодальный поиск

Поиск по разным типам данных через единое векторное пространство.

```
┌──────────┐     ┌──────────────┐     ┌──────────────┐
│  Текст   │────▶│              │────▶│ [0.12, ...]  │
└──────────┘     │  CLIP /      │     └──────────────┘
                 │  мультимод.  │
┌──────────┐     │  модель      │     ┌──────────────┐
│  Фото    │────▶│              │────▶│ [0.15, ...]  │
└──────────┘     └──────────────┘     └──────────────┘

Запрос текстом → поиск по изображениям (и наоборот)
```

---

## 7. Архитектурные решения

### 7.1. Когда использовать pgvector (единая БД)

```
✓ До 5–10 млн векторов
✓ Уже используете PostgreSQL
✓ Нужны ACID-транзакции и JOIN-ы
✓ Простая архитектура без дополнительных сервисов
✓ Гибридные запросы: вектор + SQL
```

```
┌─────────────────────────────────────┐
│          PostgreSQL + pgvector      │
│                                     │
│  Реляционные  │  Векторные данные   │
│  таблицы      │  (эмбеддинги)       │
│               │                     │
│  equipment    │  document_chunks    │
│  sensors      │  (embedding vector) │
│  downtime     │                     │
└─────────────────────────────────────┘
```

### 7.2. Когда использовать отдельную векторную БД

```
✓ Более 10 млн векторов
✓ Требуется горизонтальное масштабирование
✓ Latency < 10 мс критична
✓ Сложные сценарии фильтрации
✓ Мультимодальный поиск
```

```
┌──────────────────┐     ┌──────────────────┐
│   PostgreSQL     │     │   Qdrant/Milvus  │
│  (основные      │     │  (векторный      │
│   данные)        │◄───▶│   поиск)         │
│                  │     │                  │
│  equipment,      │     │  embeddings,     │
│  sensors, ...    │     │  ANN-индексы     │
└──────────────────┘     └──────────────────┘
        │                        │
        └────────┬───────────────┘
                 ▼
         Приложение / RAG
```

### 7.3. Дерево принятия решений

```
                    Нужен векторный поиск?
                           │
                    ┌──────┴──────┐
                    Да            Нет → Реляционная БД
                    │
              Сколько векторов?
                    │
          ┌─────────┼─────────┐
        < 1 млн   1-10 млн   > 10 млн
          │         │            │
        Chroma   pgvector    Qdrant / Milvus
       (прототип) (продакшн)  (масштаб)
                    │
              Нужен ли облачный
              managed-сервис?
                    │
              ┌─────┴─────┐
              Да          Нет
              │            │
        Yandex Managed  Self-hosted
        PostgreSQL      Qdrant
        + pgvector
```

---

## 8. Практические рекомендации

### 8.1. Выбор размерности эмбеддингов

| Размерность | Качество | Память на 1 млн записей | Скорость |
|------------|----------|------------------------|----------|
| 256 | Достаточное | ~1 ГБ | Быстро |
| 384 | Хорошее | ~1.5 ГБ | Быстро |
| 768 | Высокое | ~3 ГБ | Среднее |
| 1536 | Очень высокое | ~6 ГБ | Среднее |
| 3072 | Максимальное | ~12 ГБ | Медленнее |

### 8.2. Оптимизация производительности

| Проблема | Решение |
|----------|---------|
| Медленный поиск | Увеличить `ef_search` (HNSW), добавить GPU (Milvus) |
| Высокое потребление памяти | Использовать PQ-квантизацию или меньшую размерность |
| Низкий recall | Увеличить `ef_construction`, `M` (HNSW) или `nprobe` (IVF) |
| Медленная вставка | Батчевая загрузка, отложенная индексация |
| Устаревшие данные | Инкрементальное обновление с TTL |

### 8.3. Чек-лист внедрения

```
□ Определить модель эмбеддингов и размерность
□ Выбрать метрику расстояния (cosine для текста)
□ Оценить объём данных (текущий и рост)
□ Выбрать стратегию чанкинга (размер, перекрытие)
□ Настроить параметры индекса (M, ef для HNSW)
□ Реализовать пайплайн обновления эмбеддингов
□ Настроить мониторинг (latency, recall, размер индекса)
□ Провести нагрузочное тестирование
□ Настроить резервное копирование
```

---

## 9. Пример для предприятия «Руда+»

### Сценарий: поиск по технической документации

```sql
-- PostgreSQL + pgvector
-- Таблица для хранения документации с эмбеддингами

CREATE EXTENSION IF NOT EXISTS vector;

CREATE TABLE tech_docs (
    doc_id      SERIAL PRIMARY KEY,
    title       VARCHAR(500) NOT NULL,
    section     VARCHAR(200),
    chunk_text  TEXT NOT NULL,
    equipment_type VARCHAR(100),
    mine        VARCHAR(100),
    embedding   VECTOR(256),         -- YandexGPT Embeddings
    created_at  TIMESTAMP DEFAULT NOW()
);

-- HNSW-индекс для быстрого поиска
CREATE INDEX idx_tech_docs_hnsw
ON tech_docs USING hnsw (embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 200);

-- Индекс для фильтрации
CREATE INDEX idx_tech_docs_equip ON tech_docs(equipment_type);
CREATE INDEX idx_tech_docs_mine ON tech_docs(mine);

-- Поиск: "какой интервал замены масла для ПДМ"
-- (вектор запроса получен от модели эмбеддингов)
SELECT
    title,
    section,
    chunk_text,
    1 - (embedding <=> :query_vector) AS similarity
FROM tech_docs
WHERE equipment_type = 'ПДМ'
ORDER BY embedding <=> :query_vector
LIMIT 5;
```

### Архитектура RAG-системы для «Руда+»

```
┌──────────────────────────────────────────────────────────┐
│                   Оператор / Инженер                     │
│              "Почему ПДМ-7 встала на горизонте 320?"     │
└─────────────────────────┬────────────────────────────────┘
                          │
                ┌─────────▼─────────┐
                │  API-шлюз         │
                └─────────┬─────────┘
                          │
         ┌────────────────┼────────────────┐
         ▼                ▼                ▼
┌────────────────┐ ┌────────────┐ ┌────────────────┐
│ PostgreSQL     │ │ pgvector   │ │ TimescaleDB    │
│ (журнал       │ │ (техдоку-  │ │ (телеметрия    │
│  простоев)     │ │  ментация) │ │  датчиков)     │
└───────┬────────┘ └─────┬──────┘ └───────┬────────┘
        │                │                │
        └────────────────┼────────────────┘
                         ▼
                ┌─────────────────┐
                │ Формирование    │
                │ промпта с       │
                │ контекстом      │
                └────────┬────────┘
                         ▼
                ┌─────────────────┐
                │   YandexGPT     │
                │   (генерация    │
                │    ответа)      │
                └────────┬────────┘
                         ▼
        "ПДМ-7 остановлена по причине
         перегрева гидравлики (датчик T-04
         зафиксировал 98°C при норме 85°C).
         Рекомендация: проверить уровень
         гидравлической жидкости..."
```

---

## 10. Источники и дополнительные материалы

1. **pgvector:** github.com/pgvector/pgvector — расширение для PostgreSQL
2. **Qdrant:** qdrant.tech/documentation — документация Qdrant
3. **Milvus:** milvus.io/docs — документация Milvus
4. **Weaviate:** weaviate.io/developers/weaviate — документация Weaviate
5. **HNSW:** Malkov, Yashunin, "Efficient and Robust Approximate Nearest Neighbor using Hierarchical Navigable Small World Graphs" (2018)
6. **ANN Benchmarks:** ann-benchmarks.com — сравнение производительности алгоритмов
7. **YandexGPT Embeddings:** yandex.cloud/docs/foundation-models/concepts/embeddings

---

*Справка подготовлена в рамках курса «Практикум по анализу и моделированию данных»*
*Дата: февраль 2026*
